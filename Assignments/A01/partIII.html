<!-- 
 /*****************************************************************************\
*
*  Author:           Rykir Evans (See Credits)
*  Email:            rjevans0408@my.msutexas.edu | rykirjoe@yahoo.com
*  Title:            Beginner WebGL Program (Part III)
*  Course:           CMPS 4213 Computer Graphics
*  Professor:        Dr. Mahmoud Eldefrawy
*  Semester:         Fall 2025
*
*  Description:
*         This program introuces the concept of WebGL and scene creation
*         beyond singular triangles, incorporating interactively redrawing
*         the canvas, perspective drawings, and functions incorporating
*         repeated element drawing. The scene depicted is a brick building
*         with a tower structure and a road passing by.
*         
*  Usage:
*         One way to use this program is to download the `partIII.html` file
*         and run locally. Other alternatives are available at your 
*         discretion.
*         
*  Files: 
*         partIII.html
\******************************************************************************/ 
-->

<!-- 
CREDITS: 
Starter code was provided by the "WebGL - Drawing a Triangle"
tutorial from `tutorialspoint`
https://www.tutorialspoint.com/webgl/webgl_drawing_a_triangle.htm

The function `makeBrickWall(...)` was modified from an AI-generated function 
and created in-part thanks to information learned from AI.
-->
<!doctype html>
<html>
   <body>
      <canvas width = "570" height = "570" id = "my_Canvas"></canvas>
      <br>
      <button onclick="changeToD()">Change time of day</button>

      <script>
         var ToD = [0.3, 0.75, 0.85, 1];
         // var sunOrMoon = [1.0, 1.0, 0.0, 1.0];
         var isDay = true;

         function changeToD()
         {
            // Evaluate current state of day and change canvas color depending on state.
            if(isDay)
            {
               // Nightime color
               ToD = [0.1, 0.15, 0.25, 1.0];
               // sunOrMoon = [1.0, 1.0, 1.0, 1.0];
            }
            else
            {
               // Daytime color
               ToD = [0.3, 0.75, 0.85, 1.0];
               // sunOrMoon = [1.0, 1.0, 0.0, 1.0];
            }

            isDay = !isDay;

            // Redraw canvas
            draw();
         }

         // Encapsulated commands for drawing
         function draw() 
         {
            gl.clearColor(...ToD);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 7);
         }


         // Encapsulated commands for handling the buffe
         function processBuffer(glBufferType, theBuffer, dataArray)
         {
            // Bind appropriate array buffer to it
            gl.bindBuffer(glBufferType, theBuffer);
            
            // Differentiate based on whether it is meant to be a vertex buffer or a index buffer
            if (glBufferType === gl.ELEMENT_ARRAY_BUFFER) 
            {gl.bufferData(glBufferType, new Uint16Array(dataArray), gl.STATIC_DRAW);} 
            else 
            {gl.bufferData(glBufferType, new Float32Array(dataArray), gl.STATIC_DRAW);}

            // Unbind the buffer
            gl.bindBuffer(glBufferType, null);
         }

         // Encapsulated commands for making a shader
         function makeShader(shaderType, code)
         {
            var returnMe = gl.createShader(shaderType);

            // Attach vertex shader source code
            gl.shaderSource(returnMe, code);

            // Compile the vertex shader
            gl.compileShader(returnMe);

            return returnMe;
         }

         // Encapsulated commands for making a shader program
         function makeShaderProgram(shaderArray)
         {
            var returnMe = gl.createProgram();

            // Attach a vertex shader
            gl.attachShader(returnMe, shaderArray[0]);

            // Attach a fragment shader
            gl.attachShader(returnMe, shaderArray[1]);

            // Link both the programs
            gl.linkProgram(returnMe);

            // Use the combined shader program object
            gl.useProgram(returnMe);

            return returnMe;
         }

         // Brick wall function
         function makeBrickWall(rows, cols, brickWidth, brickHeight, gap, startX, startY) 
         {
         const bvertices = [];
         for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {

               // Horizontal offset for alternate rows (brick pattern)
               const offsetX = (row % 2 === 0) ? 0 : brickWidth / 2;

               const z = 0.0;

               // If-else chain for handling edges of brick wall
               if(col == cols - 1)
               {
                  // Last column is offset onto the second to last brick
                  x = startX + col * (brickWidth  + gap);
                  y = startY + row * (brickHeight + gap);
                  
               }
               else if((col == 0))
               {
                  // First column is slightly pushed over to even up starting edge
                  x = startX + col * (brickWidth + gap) + brickWidth;
                  y = startY + row * (brickHeight + gap);

               }
               else
               {
                  // All columns in between are offset if they are an even row.
                  x = startX + col * (brickWidth + gap) + offsetX;
                  y = startY + row * (brickHeight + gap);
               }

               // Brick Color
               const color =  [0.75, 0.30, 0.05, 1.0];

               // Define two triangles to form one brick
               const brick = [
                  // Triangle 1
                  x, y, z, ...color,
                  x + brickWidth, y, z, ...color,
                  x + brickWidth, y + brickHeight, z, ...color,

                  // Triangle 2
                  x, y, z, ...color,
                  x + brickWidth, y + brickHeight, z, ...color,
                  x, y + brickHeight, z, ...color
               ];

               bvertices.push(...brick);
            }
         }

         return bvertices;
      }


         /*============== Creating a canvas ====================*/
         var canvas = document.getElementById('my_Canvas');
         const gl = canvas.getContext('webgl');
      
         /*======== Defining and storing the geometry ===========*/

         // Complex perspective road with stripes
         var RDvertices = [
            // Long Road Triangle 1 (Black)
            0.1, -1.0, 0.0,    0.0, 0.0, 0.0, 1.0,  
            0.8, -0.5, 0.0,     0.0, 0.0, 0.0, 1.0,  
            0.95,  -0.5, 0.0,    0.0, 0.0, 0.0, 1.0,  

            // Long Road Triangle 2 (Black)
            0.8,  -0.5, 0.0,   0.0, 0.0, 0.0, 1.0,  
            -0.6,  -1.0, 0.0,  0.0, 0.0, 0.0, 1.0,  
            0.1, -1.0, 0.0,    0.0, 0.0, 0.0, 1.0,

            // // Perpendicular Road Triangle 1 (Black)
            // 0.3,  -0.7, 0.0,   0.0, 0.0, 0.0, 1.0,  
            // -1.0,  -0.7, 0.0,  0.0, 0.0, 0.0, 1.0,  
            // 0.1, -0.8, 0.0,    0.0, 0.0, 0.0, 1.0,

            // // Perpendicular Road Triangle 1 (Black)
            // -1.0,  -0.6, 0.0,   0.0, 0.0, 0.0, 1.0,  
            // -1.0,  -0.7, 0.0,  0.0, 0.0, 0.0, 1.0,  
            // 0.3, -0.7, 0.0,    0.0, 0.0, 0.0, 1.0,

            // Road Stripe 1 Tri 1 (White)
            -0.15, -0.955, -0.1,    1.0, 1.0, 1.0, 1.0,
            -0.07, -0.97, 0.0,    1.0, 1.0, 1.0, 1.0,
            0.12, -0.87, 0.0,    1.0, 1.0, 1.0, 1.0,

            
            // Road Stripe 1 Tri 2 (White)
            -0.15, -0.955, -0.1,    1.0, 1.0, 1.0, 1.0,
            0.07, -0.86, -0.1,    1.0, 1.0, 1.0, 1.0,
            0.12, -0.87, -0.1,    1.0, 1.0, 1.0, 1.0,

            // Road Stripe 2 Tri 1 (White)
            0.27, -0.755, -0.1,    1.0, 1.0, 1.0, 1.0,
            0.35, -0.77, 0.0,    1.0, 1.0, 1.0, 1.0,
            0.5, -0.68, 0.0,    1.0, 1.0, 1.0, 1.0,

            // Road Stripe 2 Tri 2 (White)
            0.27, -0.755, -0.1,    1.0, 1.0, 1.0, 1.0,
            0.45, -0.68, -0.1,    1.0, 1.0, 1.0, 1.0,
            0.5, -0.68, -0.1,    1.0, 1.0, 1.0, 1.0,

            // Road Stripe 3 Tri 1 (White)
            0.7, -0.575, -0.1,    1.0, 1.0, 1.0, 1.0,
            0.75, -0.59, 0.0,    1.0, 1.0, 1.0, 1.0,
            0.85, -0.525, 0.0,    1.0, 1.0, 1.0, 1.0,

            // Road Stripe 3 Tri 2 (White)
            0.7, -0.575, -0.1,    1.0, 1.0, 1.0, 1.0,
            0.825, -0.52, -0.1,    1.0, 1.0, 1.0, 1.0,
            0.85, -0.525, -0.1,    1.0, 1.0, 1.0, 1.0,
         ];

         // Green ground
         var GNDvertices = [

            // Ground Triangle 1 (Green)
            -1.0, -1.0, 0.1,    0.0, 1.0, 0.0, 1.0,  
            1.0, -1.0, 0.1,    0.0, 1.0, 0.0, 1.0,  
            1.0,  -0.5, 0.1,   0.0, 1.0, 0.0, 1.0,  

            // Ground Triangle 2 (Green)
            -1.0,  -0.5, 0.1,   0.0, 1.0, -0.1, 1.0,  
            -1.0,  -1.0, 0.1,   0.0, 1.0, -0.1, 1.0,  
            1.0, -0.5, 0.1,     0.0, 1.0, -0.1, 1.0,
         ]

         // I was going to make a sun and moon with variable color but it didn't work as expected
         // var sunMoon = 
         // [
         //    // Sun/Moon Triangle 1 (Top, variable color)
         //    0.45, 0.5, 0.0, ...sunOrMoon,
         //    0.65, 0.5, 0.0, ...sunOrMoon,
         //    0.55, 0.6, 0.0, ...sunOrMoon,

         //    // Sun/Moon Triangle 2 (Bottom, variable color)
         //    0.45, 0.5, 0.0, ...sunOrMoon,
         //    0.65, 0.5, 0.0, ...sunOrMoon,
         //    0.55, 0.4, 0.0, ...sunOrMoon,
         // ]

         // Create a rectangular brick wall 
         const BRtower = makeBrickWall(25, 7, 0.05, 0.02, 0.003, -0.55, -.04);
         const BRwall = makeBrickWall(20, 27, 0.05, 0.02, 0.003, -0.85, -0.5);

         // Single array of all verticies
         const vertices = [...GNDvertices, ...BRtower, ...BRwall, ...RDvertices];


      
         
         // Create empty buffer objects to store vertex & index buffers
         var vertex_buffer = gl.createBuffer();

         // Bind buffers and send data
         processBuffer(gl.ARRAY_BUFFER, vertex_buffer, vertices);
         // processBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer, indices);

         /*================ Shaders ====================*/
         
         // Vertex shader source code
         var vertCode = `
            attribute vec3 coordinates;
            attribute vec4 vertexColor;
            varying vec4 fragColor;

            void main(void) {
               gl_Position = vec4(coordinates, 1.0);
               fragColor = vertexColor;
            }
         `;


         //fragment shader source code
         var fragCode = `
            precision mediump float;
            varying vec4 fragColor;

            void main(void) {
               gl_FragColor = fragColor;
            }
         `;

            
         // Create a vertex and fragment shader objects
         var vertShader = makeShader(gl.VERTEX_SHADER, vertCode);
         var fragShader = makeShader(gl.FRAGMENT_SHADER, fragCode);

         // Create a shader program object to store
         // the combined shader program
         var shaderProgram = makeShaderProgram([vertShader, fragShader]);



         /*======= Associating shaders to buffer objects =======*/

         var FSIZE = Float32Array.BYTES_PER_ELEMENT; // 4
         var stride = 7 * FSIZE;

         // Bind vertex buffer object
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         // gl.bindBuffer(gl.ARRAY_BUFFER, brick_buffer);

         // Bind index buffer object
         // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);
         
         // Get the attribute location
         var coord = gl.getAttribLocation(shaderProgram, "coordinates");

         // Point an attribute to the currently bound VBO
         gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, stride, 0); 
         
         // Enable the attribute
         gl.enableVertexAttribArray(coord);

         // Same steps for the color vector
         var color = gl.getAttribLocation(shaderProgram, "vertexColor");
         gl.vertexAttribPointer(color, 4, gl.FLOAT, false, stride, 3 * FSIZE);
         gl.enableVertexAttribArray(color);

         /*=========Drawing the triangle===========*/
         draw();
      </script>
    </body>
</html>